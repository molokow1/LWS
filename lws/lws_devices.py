from abc import ABC, abstractmethod, abstractproperty
from enum import Enum
import random

import simpy
from lws.lws_utils import ConfigReader, airtime, mins_to_ms, ms_to_date_time, ms_to_mins
from lws.path_loss_model import soil_path_loss_model


class DeviceType(Enum):
    END_DEVICE = 1
    BASE_STATION = 2


class PacketStatus(Enum):
    SUCCESS = 1
    LOST = 2
    COLLIDED = 3


class PacketType(Enum):
    Data = 1
    DataAck = 2
    ACK = 3
    LinkCheckReq = 4
    LinkCheckAns = 5
    LinkADRReq = 6
    LinkADRAns = 7
    DutyCycleReq = 8
    DutyCycleAns = 9
    RXParamsSetupReq = 10
    RXParamSetupAns = 11
    DevStatusReq = 12
    DevStatusAns = 13
    NewChaneelReq = 14
    NewChannelAns = 15
    RXTimingSetupReq = 16
    RXTimingSetupAns = 17


class Packet(object):
    """Packet encapsulates LoRa parameters that represents a LoRa PHY packet
    TODO: add bit fields so that the packet can be converted to a binary form

    """

    def __init__(self, device_id, device_type, packet_type, timestamp, lora_params):
        """init

        Arguments:
            device_id {int} -- a LWSDevice with device_id that made this packet
            device_type {DeviceType} -- the type of device that made this packet
            packet_type {PacketType} -- the type of this packet
            timestamp {int} -- unix timestamp when this packet is made
            lora_params {dict} -- a python dict containing all the LoRa params
        """
        self.device_id = device_id
        self.device_type = device_type
        self.packet_type = packet_type
        self._set_lora_params(lora_params)
        self.timestamp = timestamp
        self._rssi = None

    def _set_lora_params(self, lora_params):
        self.freq = random.choice(lora_params['freq_list'])
        self.sf = lora_params['sf']
        self.cr = lora_params['cr']
        self.bw = lora_params['bw']
        self.tx_pow = lora_params['tx_pow']
        self.pkt_len = lora_params['pkt_len']
        # self.trans_range = 150
        self.symbol_time = (2.0**self.sf)/self.bw
        # self.arrive_time = 0
        self.airtime = airtime(self.sf, self.cr, self.pkt_len, self.bw)

    def __repr__(self):
        return "{} packet generated by {}[{}] with a length of {} bytes".format(self.packet_type, self.device_type, self.device_id, self.pkt_len)


class EndDeviceStates(Enum):
    START = 1
    PRE_TRANSMIT_WAIT = 2
    TRANSMIT = 3
    RX1_DELAY = 4
    RX1_RECV = 5
    RX2_DELAY = 6
    RX2_RECV = 7


class BasestationStates(Enum):
    START = 1
    WAIT_FOR_UPLINK = 2
    PROCESS_UPLINK = 3
    SEND_DOWNLINK_RX1 = 4
    SEND_DOWNLINK_RX2 = 5


class LWSDevice(ABC):

    """Base class to be inhereted from the device implementations such as EndDevice class and BaseStation class.


    Arguments:
        ABC {Abstract Base Class} --

    Raises:
        NotImplementedError: You need to implement some methods when you are implementing a LWSDevice class

    """

    def __init__(self, device_id, x, y, dist, global_config, env):
        """init

        Arguments:
            device_id {int} -- the id of this device
            x {float} -- the x coordinate of the position of this device
            y {float} -- the y coordinate of the position of this device
            dist {float} -- the distance between this device and the basestation(TODO: remove this from the LWSDevice class)
            global_config {Config} -- global config class
            env {simpy.Environment} -- global simpy environment
        """
        super().__init__()

        self.env = env
        self.send_conns = {}
        self.recv_conns = {}
        self.recv_pkts = {}
        self.recv_rssis = {}

        self.device_id = device_id
        self._x = x
        self._y = y
        self.global_config = global_config
        self.dist = dist

        self.init_params()

        self._num_pkt_sent = 0
        self._num_pkt_received = 0

        self._pkt_loss_count = 0
        self._pkt_collision_count = 0

        self.received_packet = None
        self._event_mapping = {}

        # self._current_state = None

        self._make_event_dict()

    def _make_event_dict(self):
        self._event_dict = {}
        for e in self.event_list:
            self._event_dict[e] = self.env.event()

    # def add_event(self, timestamp, event):
    #     self.event_list.append({
    #         "timestamp": timestamp,
    #         "event": event
    #     })
    @abstractmethod
    def start_fsm(self, device_id):
        pass

    def add_event_mapping(self, device_id, event_dict):
        self._event_mapping[device_id] = event_dict

    @property
    def event_mapping(self):
        return self._event_mapping

    @property
    def event_dict(self):
        return self._event_dict

    def init_params(self):
        # TODO: change the global_config attributes to better names e.g. device_sf
        self.sf = self.global_config.nodeSF
        self.cr = self.global_config.nodeCR
        self.bw = self.global_config.nodeBW
        self.tx_pow = self.global_config.pTx
        self.pkt_len = self.global_config.pktLen

    # return a dict of lora_params
    @property
    def lora_params(self):
        return {
            'freq_list': self.global_config.centreFreqList,
            'sf': self.sf,
            'cr': self.cr,
            'bw': self.bw,
            'tx_pow': self.tx_pow,
            'pkt_len': self.pkt_len,
        }

    @abstractmethod
    def send_packet(self, packet, target_device):
        pass

    @abstractmethod
    def receive_packet(self, packet, from_device, status, timestamp):
        pass

    def _trigger_event(self, event_str):
        self._event_dict[event_str].succeed()
        self._event_dict[event_str] = self.env.event()

    def create_sending_connection(self, device_id):
        self.send_conns[device_id] = simpy.Store(self.env)
        return self.send_conns[device_id]

    def add_receiving_connection(self, device_id, conn):
        self.recv_conns[device_id] = conn
        self.recv_pkts[device_id] = []
        self.recv_rssis[device_id] = []

    def make_packet(self, packet_type, timestamp):
        return Packet(device_id=self.device_id, device_type=self.device_type,
                      packet_type=packet_type, timestamp=timestamp, lora_params=self.lora_params)

    @property
    def num_pkt_sent(self):
        return self.num_pkt_sent

    @property
    def num_pkt_received(self):
        return self._num_pkt_received

    @property
    def pkt_collision_count(self):
        return self.pkt_collision_count

    @property
    def pkt_loss_count(self):
        return self.pkt_loss_count

    @abstractproperty
    def device_type(self):
        raise NotImplementedError

    @abstractproperty
    def event_list(self):
        raise NotImplementedError


class EndDevice(LWSDevice):

    device_type = DeviceType.END_DEVICE

    event_list = ["uplink_sent", "ed_polling_event"]
    # the events that this class is capable of emitting by setting event.succeed()
    # so that other devices that has established full duplex connection with this device can yield

    def __init__(self, device_id, x, y, dist, global_config, pkt_type, env):
        super().__init__(device_id, x, y, dist, global_config, env)
        self.pkt_type = pkt_type
        self._current_state = EndDeviceStates.START
        # end_device specific stats
        self._num_pkt_retransmitted = 0
        self._downlink_loss_count = 0
        self._pathloss_model = soil_path_loss_model(
            global_config.vwc, global_config.bulkDensity, global_config.particleDensity, global_config.sandFrac, global_config.clayFrac)

    def send_packet(self, packet, target_device, timestamp):
        yield self.send_conns[target_device].put(packet)
        print("{} sent at {}".format(packet, self.env.now))
        self._num_pkt_sent += 1

    def receive_packet(self, from_device, status=None):
        received_packet = yield self.recv_conns[from_device].get()
        print("Got {} from {} at {}".format(
            received_packet, from_device, self.env.now))
        self.received_packet = received_packet

    def send_uplink(self, device_id):
        # initial delay
        send_time_ms = mins_to_ms(self.global_config.avgSendTime)

        initial_delay = random.expovariate(
            1.0/float(send_time_ms))
        # print("Initial delay: {}".format(initial_delay))
        yield self.env.timeout(initial_delay)

        packet = self.make_packet(self.pkt_type, self.env.now)
        rssi = self._calc_rssi(packet.freq)

        # print("Airtime: {}".format(packet.airtime))
        # airtime delay
        yield self.env.timeout(packet.airtime)

        self.env.process(self.send_packet(
            (packet, rssi), device_id, self.env.now))
        print("Sent at {}".format(self.env.now))

    def event_test_proc(self):
        while True:
            yield self.env.timeout(random.randint(10, 20))

            print("ED: starting event at {}".format(self.env.now))

            self._trigger_event("ed_polling_event")

    def start_fsm(self, from_device_id):
        """the main finite state machine process which models the top level LoRaWAN class A state transitions e.g. transmit -> rx1_delay -> rx1_window -> rx2_delay -> rx2_window -> transmit 

        Arguments:
            from_device_id {int} -- the device id of the device this object has established a full-duplex connection with e.g. an end device and a basestation
        """
        send_conn = self.send_conns[from_device_id]
        while True:

            if self._current_state == EndDeviceStates.START:
                print("Entered: {} at {}".format(
                    self._current_state, ms_to_date_time(self.env.now)))
                self._current_state = EndDeviceStates.PRE_TRANSMIT_WAIT

            elif self._current_state == EndDeviceStates.PRE_TRANSMIT_WAIT:
                print("Entered: {} at {}".format(
                    self._current_state, ms_to_date_time(self.env.now)))

                pre_transmission_delay = random.expovariate(
                    1.0 / float(self.global_config.avgSendTime))

                pre_transmission_delay = mins_to_ms(pre_transmission_delay)

                print("pre_transmission_delay :{0:.2f}mins".format(
                    ms_to_mins(pre_transmission_delay)))

                yield self.env.timeout(pre_transmission_delay)

                self._current_state = EndDeviceStates.TRANSMIT

            elif self._current_state == EndDeviceStates.TRANSMIT:

                packet = self.make_packet(self.pkt_type, self.env.now)
                rssi = self._calc_rssi(packet.freq)

                print("Entered: {} at {}".format(
                    self._current_state, ms_to_date_time(self.env.now)))

                # send packet
                yield send_conn.put((packet, rssi))
                self._trigger_event("uplink_sent")

                if packet.packet_type == PacketType.Data:
                    self._current_state = EndDeviceStates.START
                else:
                    self._current_state = EndDeviceStates.RX1_DELAY

            elif self._current_state == EndDeviceStates.RX1_DELAY:
                # convert RX1_DELAY from s to ms
                yield self.env.timeout(self.global_config.RX1_DELAY * 1000)
                self._current_state = EndDeviceStates.RX1_RECV

            elif self._current_state == EndDeviceStates.RX1_RECV:
                # LoRaWAN spec says that this recv window should be long enough to detect a preamble
                # therefore should have something like this
                # yield rx_window_timeout | rx_recv
                # if rx_window_timeout == true:
                # go to rx2
                pass

            elif self._current_state == EndDeviceStates.RX2_DELAY:
                yield self.env.timeout(self.global_config.RX2_DELAY * 1000)
                self._current_state = EndDeviceStates.RX2_RECV

            elif self._current_state == EndDeviceStates.RX2_RECV:
                pass
            else:
                pass  # abort

    def _calc_rssi(self, freq):
        pathloss = self._pathloss_model.calc_approximated_path_loss(
            freq, self.global_config.burialDepth, self.dist, self.global_config.baseStationHeight)

        rssi = self.global_config.pTx - self.global_config.GL - pathloss
        return rssi

    @property
    def num_pkt_retransmitted(self):
        return self._num_pkt_retransmitted

    @property
    def downlink_loss_count(self):
        return self._downlink_loss_count

    def schedule_retransmission(self):
        pass


class BaseStation(LWSDevice):

    device_type = DeviceType.BASE_STATION

    event_list = ["bs_polling_event", "bs_interrupt"]

    def __init__(self, device_id, x, y, dist, global_config, env):
        super().__init__(device_id, x, y, dist, global_config, env)
        self._current_state = BasestationStates.START

    def send_packet(self, packet, target_device):
        yield self.send_conns[target_device].put(packet)

    def receive_packet(self, from_device):
        recv_conn = self.recv_conns[from_device]
        packet, rssi = yield recv_conn.get()
        print("Received packet {} at {}".format(rssi, self.env.now))
        self.recv_pkts[from_device].append(packet)
        self.recv_rssis[from_device].append(rssi)

    def start_fsm(self, from_device_id):
        event_dict = self._event_mapping[from_device_id]
        recv_conn = self.recv_conns[from_device_id]
        while True:
            if self._current_state == BasestationStates.START:
                print("BS: Entered START at {}".format(
                    ms_to_date_time(self.env.now)))
                self._current_state = BasestationStates.WAIT_FOR_UPLINK
                # yield self.env.timeout(1)

            elif self._current_state == BasestationStates.WAIT_FOR_UPLINK:
                print("BS: Entered WAIT_FOR_UPLINK at {}".format(
                    ms_to_date_time(self.env.now)))
                yield event_dict["uplink_sent"]
                print("BS: got uplink event at: {}".format(
                    ms_to_date_time(self.env.now)))
                packet, rssi = yield recv_conn.get()
                print("BS: Received packet {} at {}".format(
                    rssi, ms_to_date_time(self.env.now)))
                self._current_state = BasestationStates.START
            elif self._current_state == BasestationStates.PROCESS_UPLINK:
                pass
            elif self._current_state == BasestationStates.SEND_DOWNLINK_RX1:
                pass
            elif self._current_state == BasestationStates.SEND_DOWNLINK_RX2:
                pass

    def _calc_sensitivity(self, sf, bw):
        return self.global_config.sensitivity_list[sf - 7, [125, 250, 500].index(bw) + 1]

    def receive_uplink(self, from_device):
        recv_conn = self.recv_conns[from_device]
        packet, rssi = yield recv_conn.get()
        self.recv_pkts[from_device].append(packet)
        self.recv_rssis[from_device].append(rssi)
        # print("{}th Packet with RSSI: {:10.2f} at {:10.2f}".format(
        # len(self.recv_pkts[from_device]), rssi, self.env.now))
        sens = self._calc_sensitivity(packet.sf, packet.bw)
        if rssi < sens:
            print("Packet Lost")
            # packet lost
        else:
            print("Packet not lost")
            # check collision

    def event_test_proc(self):
        while True:
            # yield self.env.timeout(random.randint(20, 30))

            print("BS: reacting to ed event at {}".format(self.env.now))

            yield self._event_mapping[0]["ed_polling_event"]
            print("BS: Got event trigger at {}".format(self.env.now))


def create_full_duplex_connection(end_device, basestation):
    """the helper function that creates full duplex connection between an end device and basestation by adding each other to their dictionary of sending and receiving channels and evenet mapping

    Arguments:
        end_device {EndDevice} -- 
        basestation {BaseStation} -- 
    """
    end_device_send_conn = end_device.create_sending_connection(
        basestation.device_id)
    base_station_send_conn = basestation.create_sending_connection(
        end_device.device_id)

    end_device.add_receiving_connection(
        basestation.device_id, base_station_send_conn)
    basestation.add_receiving_connection(
        end_device.device_id, end_device_send_conn)

    end_device.add_event_mapping(basestation.device_id, basestation.event_dict)
    basestation.add_event_mapping(end_device.device_id, end_device.event_dict)


if __name__ == "__main__":
    env = simpy.Environment()
    config = ConfigReader("./lora_sim_config.json")
    end_device = EndDevice(
        0, 1, 2, 3, config, pkt_type=PacketType.Data, env=env)
    print(end_device.sf, end_device.device_type)
